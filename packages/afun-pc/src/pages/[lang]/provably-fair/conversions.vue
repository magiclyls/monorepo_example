<script lang="ts" setup>
import { getLang } from '@tg/vue-i18n'

import { computed } from 'vue'

const lang = getLang()

const t = computed(() => {
  const translations = {
    'en-US': {
      bytesToFloats: 'Bytes to Floats',
      bytesDesc: 'The output of the Random Number Generator (byteGenerator) function is a hexadecimal 32-byte hash. As explained under the cursor implementation, we use 4 bytes of data to generate a single game result. Each set of 4 bytes are used to generate floats between 0 and 1 (4 bytes are used instead of one to ensure a higher level of precision when generating the float.) It is with these generated floats that we derive the formal output of the provable fair algorithm before it is translated into game events.',
      floatsToEvents: 'Floats to Game Events',
      floatsIntro: 'Where the process of generating random outputs is universal for all our games, it\'s at this point in the game outcome generation where a unique procedure is implemented to determine the translation from floats to game events.',
      floatsDesc: 'The randomly generated float is multiplied by the possible remaining outcomes of the particular game being played. For example: In a game that uses a 52 card deck, this would simply be done by multiplying the float by 52. The result of this equation is then translated into a corresponding game event. For games where multiple game events are required, this process continues through each corresponding 4 bytes in the result chain that was generated using the described byteGenerator function.',
      shuffleTitle: 'Shuffle of Game Events',
      shuffleDesc1: 'For games such as Keno, Mines and Video Poker, where outcomes cannot be duplicated, we then utilise the <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates shuffle <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a> algorithm. This procedure influences the conversion process from floats to game events because each time a game event is translated, the amount of possible remaining game event possibilities has been reduced for any remaining steps in the result chain.',
      shuffleDesc2: 'As an example, in video poker, there is at first 52 cards available in the complete deck, and therefore the first game event is translated by multiplying the float by 52. Once this card has been dealt, there is only 51 remaining cards in the deck, and therefore the second card translation is done by multiplying the second float generated by 51. This continues in the same fashion until all the game events required have been generated.',
      shuffleDesc3: 'With regards to Mines and Keno, this is simply a matter of implementing the same process as explained with video poker but changing that to tiles or locations on the board or grid, ensuring that each game event generated, hasn’t already been done so beforehand in the chain of results.',
    },
    'zh-CN': {
      bytesToFloats: '字节到浮点数',
      bytesDesc: '随机数生成器（byteGenerator）函数的输出是一个 32 字节的十六进制哈希。如游标（递增数）实现部分所述，我们使用 4 个字节的数据来生成单个游戏结果。每组 4 个字节用于生成 0 到 1 之间的浮点数（使用 4 个字节而非 1 个字节，以确保生成浮点数时具有更高的精度）。正是通过这些生成的浮点数，我们在将其转换为游戏事件之前，得到可验证公平算法的正式输出。',
      floatsToEvents: '浮点数到游戏事件',
      floatsIntro: '虽然随机输出的生成过程对我们所有游戏都是通用的，但在游戏结果生成的这一环节，会实施一个独特的程序来确定浮点数到游戏事件的转换方式。',
      floatsDesc: '随机生成的浮点数会乘以该游戏当前可能剩余的结果数。例如：在使用 52 张牌的游戏中，这一操作就是将浮点数乘以 52。此方程的结果随后被转换为对应的游戏事件。对于需要生成多个游戏事件的游戏，这一过程会依次对使用 byteGenerator 函数生成的结果链中的每组 4 个字节进行处理。',
      shuffleTitle: '游戏事件的洗牌',
      shuffleDesc1: '对于如 Keno、Mines 和视频扑克（Video Poker）等不能重复结果的游戏，我们会使用 <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates 洗牌算法 <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>。此过程会影响浮点数到游戏事件的转换，因为每次游戏事件被转换后，剩余步骤中可能的游戏事件数量会相应减少。',
      shuffleDesc2: '例如，在视频扑克中，完整牌堆中最初有 52 张牌，因此第一个游戏事件通过将浮点数乘以 52 来转换。发出该牌后，牌堆中仅剩 51 张，因此第二个游戏事件通过将第二个生成的浮点数乘以 51 来转换。此过程以相同方式继续，直到生成所需的所有游戏事件。',
      shuffleDesc3: '对于 Mines 和 Keno，只需按照视频扑克中解释的相同流程，但将其应用于棋盘上的方块或位置，确保生成的每个游戏事件在结果链中之前未被生成过。',
    },
    'pt-BR': {
      bytesToFloats: 'Conversão de Bytes para Floats',
      bytesDesc: 'A saída da função Gerador de Números Aleatórios (byteGenerator) é um hash hexadecimal de 32 bytes. Como explicado na implementação do cursor, usamos 4 bytes de dados para gerar um único resultado do jogo. Cada conjunto de 4 bytes é usado para gerar números de ponto flutuante entre 0 e 1 (4 bytes são usados em vez de um para garantir um nível de precisão maior na geração do número de ponto flutuante). É com esses números de ponto flutuante gerados que derivamos a saída formal do algoritmo comprovadamente justo antes de ser traduzido em eventos do jogo.',
      floatsToEvents: 'Floats para Eventos de Jogo',
      floatsIntro: 'Embora o processo de geração de resultados aleatórios seja universal para todos os nossos jogos, é neste ponto da geração do resultado do jogo que um procedimento único é implementado para determinar a tradução de números de ponto flutuante em eventos do jogo.',
      floatsDesc: 'O número de ponto flutuante gerado aleatoriamente é multiplicado pelos possíveis resultados restantes do jogo em questão. Por exemplo: em um jogo com um baralho de 52 cartas, isso seria feito simplesmente multiplicando o número de ponto flutuante por 52. O resultado dessa equação é então convertido em um evento de jogo correspondente. Para jogos que exigem múltiplos eventos, esse processo se repete a cada conjunto de 4 bytes correspondente na cadeia de resultados gerada pela função byteGenerator descrita.',
      shuffleTitle: 'Embaralhamento de Eventos do Jogo',
      shuffleDesc1: 'Para jogos como Keno, Mines e Video Poker, onde os resultados não podem ser duplicados, utilizamos então o algoritmo <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates shuffle <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>. Este procedimento influencia o processo de conversão de números de ponto flutuante para eventos de jogo, pois a cada conversão de um evento de jogo, o número de possíveis eventos restantes é reduzido para as etapas subsequentes na cadeia de resultados.',
      shuffleDesc2: 'Por exemplo, no vídeo pôquer, inicialmente há 52 cartas disponíveis no baralho completo e, portanto, o primeiro evento do jogo é traduzido multiplicando-se o valor inicial (float) por 52. Após a distribuição dessa carta, restam apenas 51 cartas no baralho e, consequentemente, a tradução da segunda carta é feita multiplicando-se o segundo valor inicial (float) gerado por 51. Isso continua da mesma forma até que todos os eventos do jogo necessários tenham sido gerados.',
      shuffleDesc3: 'No que diz respeito a jogos como Mines e Keno, trata-se simplesmente de implementar o mesmo processo explicado para o video poker, mas alterando para peças ou locais no tabuleiro ou grade, garantindo que cada evento de jogo gerado não tenha sido realizado anteriormente na sequência de resultados.',
    },
    'vi-VN': {
      bytesToFloats: 'Chuyển đổi Byte sang Float',
      bytesDesc: 'Đầu ra của hàm byteGenerator là một hàm băm thập lục phân 32 byte. Như đã mô tả trong phần triển khai con trỏ (số tăng dần), chúng tôi sử dụng 4 byte dữ liệu để tạo ra một kết quả trò chơi duy nhất. Mỗi nhóm 4 byte được sử dụng để tạo ra một số dấu phẩy động trong khoảng từ 0 đến 1 (sử dụng 4 byte thay vì 1 byte đảm bảo độ chính xác cao hơn khi tạo số dấu phẩy động). Chính thông qua các số dấu phẩy động được tạo ra này, chúng tôi thu được đầu ra chính thức của một thuật toán công bằng có thể kiểm chứng trước khi chuyển đổi chúng thành các sự kiện trò chơi.',
      floatsToEvents: 'Từ Float đến Sự kiện Trò chơi',
      floatsIntro: 'Mặc dù quy trình tạo đầu ra ngẫu nhiên là chung cho tất cả các trò chơi của chúng tôi, nhưng một quy trình riêng được triển khai ở giai đoạn tạo kết quả trò chơi để xác định cách chuyển đổi số dấu phẩy động thành các sự kiện trò chơi.',
      floatsDesc: 'Số dấu phẩy động được tạo ngẫu nhiên được nhân với số kết quả còn lại có thể có của trò chơi. Ví dụ: trong một trò chơi sử dụng 52 lá bài, thao tác này là nhân số dấu phẩy động với 52. Kết quả của phương trình này sau đó được chuyển đổi thành sự kiện trò chơi tương ứng. Đối với các trò chơi yêu cầu tạo nhiều sự kiện trò chơi, quy trình này sẽ xử lý tuần tự từng nhóm 4 byte trong chuỗi kết quả được tạo bằng hàm byteGenerator.',
      shuffleTitle: 'Xáo trộn Sự kiện Trò chơi',
      shuffleDesc1: 'Đối với các trò chơi như Keno, Mines và Video Poker, trong đó kết quả không thể lặp lại, chúng tôi sử dụng thuật toán xáo trộn <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>. Quy trình này ảnh hưởng đến việc chuyển đổi số dấu phẩy động thành sự kiện trò chơi vì số lượng sự kiện trò chơi có thể xảy ra trong các bước còn lại sẽ giảm sau mỗi lần chuyển đổi.',
      shuffleDesc2: 'Ví dụ: trong Video Poker, bộ bài ban đầu gồm 52 lá, do đó sự kiện trò chơi đầu tiên được chuyển đổi bằng cách nhân số dấu phẩy động với 52. Sau khi chia bài, chỉ còn 51 lá bài trong bộ bài, do đó sự kiện trò chơi thứ hai được chuyển đổi bằng cách nhân số dấu phẩy động thứ hai được tạo ra với 51. Quy trình này tiếp tục theo cách tương tự cho đến khi tất cả các sự kiện trò chơi cần thiết được tạo ra.',
      shuffleDesc3: 'Đối với Mines và Keno, chỉ cần làm theo quy trình tương tự được giải thích trong Video Poker, nhưng áp dụng nó cho các ô hoặc vị trí trên bàn cờ để đảm bảo rằng mỗi sự kiện trò chơi được tạo ra chưa từng được tạo ra trước đó trong chuỗi kết quả.',
    },
    'th-TH': {
      bytesToFloats: 'การแปลงไบต์เป็นจำนวนทศนิยม',
      bytesDesc: 'ผลลัพธ์ของฟังก์ชันตัวสร้างเลขสุ่ม (byteGenerator) คือแฮชเลขฐานสิบหกขนาด 32 ไบต์ ดังที่อธิบายไว้ภายใต้การใช้งานเคอร์เซอร์ เราใช้ข้อมูล 4 ไบต์เพื่อสร้างผลลัพธ์ของเกมเดียว แต่ละชุดข้อมูล 4 ไบต์จะใช้เพื่อสร้างค่าทศนิยมระหว่าง 0 ถึง 1 (ใช้ 4 ไบต์แทนที่จะเป็น 1 เพื่อให้มั่นใจถึงความแม่นยำที่สูงขึ้นเมื่อสร้างค่าทศนิยม) จากค่าทศนิยมที่สร้างขึ้นเหล่านี้ เราได้ผลลัพธ์อย่างเป็นทางการของอัลกอริทึมที่พิสูจน์ได้ก่อนที่จะถูกแปลงเป็นเหตุการณ์ในเกม',
      floatsToEvents: 'จากทศนิยมไปสู่เหตุการณ์ในเกม',
      floatsIntro: 'ในขณะที่กระบวนการสร้างผลลัพธ์แบบสุ่มนั้นเป็นสากลสำหรับเกมทั้งหมดของเรา ในจุดนี้ของการสร้างผลลัพธ์ของเกม จะมีการนำขั้นตอนเฉพาะมาใช้ในการกำหนดการแปลจากทศนิยมไปเป็นเหตุการณ์ในเกม',
      floatsDesc: 'ทศนิยมที่สร้างขึ้นแบบสุ่มจะถูกคูณด้วยผลลัพธ์ที่เป็นไปได้ที่เหลืออยู่ของเกมที่กำลังเล่นอยู่ ตัวอย่างเช่น ในเกมที่ใช้ไพ่สำรับ 52 ใบ การทำเช่นนี้จะทำได้ง่ายๆ โดยการคูณทศนิยมด้วย 52 จากนั้นผลลัพธ์ของสมการนี้จะถูกแปลงเป็นเหตุการณ์เกมที่สอดคล้องกัน สำหรับเกมที่ต้องใช้เหตุการณ์เกมหลายเหตุการณ์ กระบวนการนี้จะดำเนินต่อไปโดยผ่านแต่ละ 4 ไบต์ที่สอดคล้องกันในห่วงโซ่ผลลัพธ์ที่สร้างขึ้นโดยใช้ฟังก์ชัน byteGenerator ที่อธิบายไว้',
      shuffleTitle: 'การสับเปลี่ยนเหตุการณ์เกม',
      shuffleDesc1: 'สำหรับเกมเช่น Keno, Mines และ Video Poker ซึ่งผลลัพธ์ไม่สามารถทำซ้ำได้ เราจะใช้ <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">อัลกอริทึม Fisher-Yates shuffle <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a> ขั้นตอนนี้มีอิทธิพลต่อกระบวนการแปลงจากจำนวนทศนิยมเป็นเหตุการณ์ในเกม เนื่องจากทุกครั้งที่มีการแปลเหตุการณ์ในเกม จำนวนความเป็นไปได้ของเหตุการณ์ในเกมที่เหลืออยู่จะลดลงสำหรับขั้นตอนที่เหลือในห่วงโซ่ผลลัพธ์',
      shuffleDesc2: 'ตัวอย่างเช่น ในวิดีโอโป๊กเกอร์ ในตอนแรกจะมีไพ่ทั้งหมด 52 ใบในสำรับ ดังนั้นเหตุการณ์แรกของเกมจึงถูกแปลโดยการคูณทศนิยมด้วย 52 เมื่อแจกไพ่ใบนี้แล้ว จะเหลือไพ่ในสำรับเพียง 51 ใบ ดังนั้นการแปลไพ่ใบที่สองจึงทำโดยการคูณทศนิยมที่สองที่สร้างขึ้นด้วย 51 การดำเนินการนี้ดำเนินต่อไปในลักษณะเดียวกันนี้จนกระทั่งเหตุการณ์ของเกมทั้งหมดที่จำเป็นถูกสร้างขึ้น',
      shuffleDesc3: 'ในส่วนของ Mines และ Keno นั้น เป็นเพียงเรื่องของการนำกระบวนการเดียวกันมาใช้ตามที่อธิบายไว้ในวิดีโอโป๊กเกอร์ แต่ให้เปลี่ยนเป็นไทล์หรือตำแหน่งบนกระดานหรือตาราง เพื่อให้แน่ใจว่าเหตุการณ์ในเกมแต่ละเหตุการณ์ที่สร้างขึ้นนั้นไม่ได้เกิดขึ้นมาก่อนในลำดับผลลัพธ์',
    },
    'hi-IN': {
      bytesToFloats: 'बाइट्स से फ़्लोट',
      bytesDesc: 'रैंडम नंबर जेनरेटर (बाइट जेनरेटर) फ़ंक्शन का आउटपुट एक हेक्साडेसिमल 32-बाइट हैश होता है। जैसा कि कर्सर कार्यान्वयन में बताया गया है, हम एक गेम परिणाम उत्पन्न करने के लिए 4 बाइट्स डेटा का उपयोग करते हैं। 4 बाइट्स के प्रत्येक सेट का उपयोग 0 और 1 के बीच फ़्लोट उत्पन्न करने के लिए किया जाता है (फ़्लोट उत्पन्न करते समय उच्च स्तर की सटीकता सुनिश्चित करने के लिए एक के बजाय 4 बाइट्स का उपयोग किया जाता है।) इन उत्पन्न फ़्लोटों के साथ ही हम सिद्ध निष्पक्ष एल्गोरिथम के औपचारिक आउटपुट को गेम इवेंट में अनुवादित करने से पहले प्राप्त करते हैं।',
      floatsToEvents: 'फ़्लोट्स से गेम इवेंट',
      floatsIntro: 'जहाँ यादृच्छिक आउटपुट उत्पन्न करने की प्रक्रिया हमारे सभी खेलों के लिए सार्वभौमिक है, वहीं खेल परिणाम निर्माण के इस बिंदु पर फ़्लोट से गेम इवेंट में अनुवाद निर्धारित करने के लिए एक अनूठी प्रक्रिया लागू की जाती है।',
      floatsDesc: 'यादृच्छिक रूप से उत्पन्न फ़्लोट को खेले जा रहे विशेष खेल के संभावित शेष परिणामों से गुणा किया जाता है। उदाहरण के लिए: 52 पत्तों वाले डेक वाले खेल में, यह फ़्लोट को 52 से गुणा करके आसानी से किया जा सकता है। इस समीकरण के परिणाम को फिर एक संगत खेल घटना में बदल दिया जाता है। जिन खेलों में कई खेल घटनाओं की आवश्यकता होती है, उनके लिए यह प्रक्रिया वर्णित बाइटजेनरेटर फ़ंक्शन का उपयोग करके उत्पन्न परिणाम श्रृंखला में प्रत्येक संगत 4 बाइट्स के माध्यम से जारी रहती है।',
      shuffleTitle: 'खेल घटनाओं का शफल',
      shuffleDesc1: 'केनो, माइन्स और वीडियो पोकर जैसे खेलों के लिए, जहाँ परिणामों की नकल नहीं की जा सकती, हम <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">फ़िशर-येट्स शफल एल्गोरिथम <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a> का उपयोग करते हैं। यह प्रक्रिया फ़्लोट से खेल घटनाओं में रूपांतरण प्रक्रिया को प्रभावित करती है क्योंकि हर बार जब किसी खेल घटना का अनुवाद किया जाता है, तो परिणाम श्रृंखला के किसी भी शेष चरण के लिए संभावित शेष खेल घटनाओं की संभावनाओं की मात्रा कम हो जाती है।',
      shuffleDesc2: 'उदाहरण के लिए, वीडियो पोकर में, पूरे डेक में पहले 52 कार्ड उपलब्ध होते हैं, और इसलिए पहले गेम इवेंट को फ्लोट को 52 से गुणा करके अनुवादित किया जाता है। एक बार यह कार्ड बांटे जाने के बाद, डेक में केवल 51 कार्ड शेष रहते हैं, और इसलिए दूसरे कार्ड का अनुवाद दूसरे फ्लोट को 51 से गुणा करके किया जाता है। यह उसी तरह जारी रहता है जब तक कि सभी आवश्यक गेम इवेंट उत्पन्न नहीं हो जाते।',
      shuffleDesc3: 'माइंस और केनो के संबंध में, यह बस उसी प्रक्रिया को लागू करने का मामला है जैसा कि वीडियो पोकर के साथ समझाया गया है, लेकिन इसे बोर्ड या ग्रिड पर टाइल्स या स्थानों में बदलना, यह सुनिश्चित करना कि प्रत्येक गेम इवेंट उत्पन्न होने से पहले ही परिणामों की श्रृंखला में ऐसा नहीं किया गया है।',
    },
    'in-ID': {
      bytesToFloats: 'Byte ke Float',
      bytesDesc: 'Keluaran dari fungsi Pembangkit Bilangan Acak (byteGenerator) adalah hash heksadesimal 32-byte. Sebagaimana dijelaskan dalam implementasi kursor, kami menggunakan 4 byte data untuk menghasilkan satu hasil permainan. Setiap set 4 byte digunakan untuk menghasilkan float antara 0 dan 1 (4 byte digunakan, bukan satu, untuk memastikan tingkat presisi yang lebih tinggi saat menghasilkan float.) Dengan float yang dihasilkan inilah kami memperoleh keluaran formal dari algoritma pembuktian adil sebelum diterjemahkan menjadi peristiwa permainan.',
      floatsToEvents: 'Float ke Peristiwa Permainan',
      floatsIntro: 'Jika proses menghasilkan keluaran acak bersifat universal untuk semua permainan kami, pada titik inilah dalam pembangkitan hasil permainan, prosedur unik diimplementasikan untuk menentukan konversi dari float ke peristiwa permainan.',
      floatsDesc: 'Float yang dihasilkan secara acak dikalikan dengan kemungkinan hasil yang tersisa dari permainan tertentu yang sedang dimainkan. Misalnya: Dalam permainan yang menggunakan setumpuk 52 kartu, hal ini cukup dilakukan dengan mengalikan float dengan 52. Hasil persamaan ini kemudian dikonversi menjadi peristiwa permainan yang sesuai. Untuk permainan yang membutuhkan beberapa peristiwa permainan, proses ini berlanjut melalui setiap 4 byte yang sesuai dalam rantai hasil yang dihasilkan menggunakan fungsi byteGenerator yang dijelaskan.',
      shuffleTitle: 'Pengacakan Peristiwa Permainan',
      shuffleDesc1: 'Untuk permainan seperti Keno, Mines, dan Video Poker, di mana hasil tidak dapat diduplikasi, kami kemudian menggunakan algoritma <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates shuffle <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>. Prosedur ini memengaruhi proses konversi dari float menjadi peristiwa permainan karena setiap kali peristiwa permainan dikonversi, jumlah kemungkinan peristiwa permainan yang tersisa telah berkurang untuk setiap langkah yang tersisa dalam rantai hasil.',
      shuffleDesc2: 'Sebagai contoh, dalam video poker, awalnya terdapat 52 kartu yang tersedia di dek lengkap, sehingga peristiwa permainan pertama diterjemahkan dengan mengalikan float dengan 52. Setelah kartu ini dibagikan, hanya tersisa 51 kartu di dek, sehingga penerjemahan kartu kedua dilakukan dengan mengalikan float kedua yang dihasilkan dengan 51. Hal ini berlanjut dengan cara yang sama hingga semua peristiwa permainan yang diperlukan telah dihasilkan.',
      shuffleDesc3: 'Sehubungan dengan Mines dan Keno, ini hanyalah masalah penerapan proses yang sama seperti yang dijelaskan pada video poker, tetapi mengubahnya menjadi petak atau lokasi di papan atau kisi, memastikan bahwa setiap peristiwa permainan yang dihasilkan belum dilakukan sebelumnya dalam rangkaian hasil.',
    },
    'ko-KR': {
      bytesToFloats: '바이트에서 부동 소수점으로',
      bytesDesc: '난수 생성기(byteGenerator) 함수의 출력은 16진수 32바이트 해시입니다. 커서 구현에서 설명한 대로, 4바이트의 데이터를 사용하여 단일 게임 결과를 생성합니다. 각 4바이트 세트는 0과 1 사이의 부동 소수점 수를 생성하는 데 사용됩니다(부동 소수점 수 생성 시 더 높은 정밀도를 보장하기 위해 1바이트 대신 4바이트를 사용합니다). 이렇게 생성된 부동 소수점 수를 사용하여 게임 이벤트로 변환하기 전에 증명 가능한 공정성 알고리즘의 공식 출력을 도출합니다.',
      floatsToEvents: '부동 소수점에서 게임 이벤트로',
      floatsIntro: '무작위 출력을 생성하는 과정은 모든 게임에서 보편적인 반면, 게임 결과 생성의 이 지점에서 부동 소수점에서 게임 이벤트로의 변환을 결정하기 위한 고유한 절차가 구현됩니다.',
      floatsDesc: '무작위로 생성된 float는 플레이 중인 특정 게임의 남은 가능한 결과에 곱해집니다. 예를 들어, 52장 카드 덱을 사용하는 게임에서는 float에 52를 곱하기만 하면 됩니다. 이 방정식의 결과는 해당 게임 이벤트로 변환됩니다. 여러 게임 이벤트가 필요한 게임의 경우, 이 과정은 앞서 설명한 byteGenerator 함수를 사용하여 생성된 결과 체인의 각 해당 4바이트에 대해 계속 진행됩니다.',
      shuffleTitle: '게임 이벤트 셔플',
      shuffleDesc1: '결과를 복제할 수 없는 케노, 마인, 비디오 포커와 같은 게임의 경우 <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates 셔플 알고리즘 <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>을 활용합니다. 이 절차는 부동 소수점에서 게임 이벤트로의 변환 프로세스에 영향을 미칩니다. 게임 이벤트가 변환될 때마다 결과 체인의 나머지 단계에서 발생할 수 있는 게임 이벤트의 남은 가능성이 줄어들기 때문입니다.',
      shuffleDesc2: '예를 들어, 비디오 포커의 경우, 처음에 전체 덱에 52장의 카드가 있으므로 첫 번째 게임 이벤트는 플로트에 52를 곱하여 변환됩니다. 이 카드가 나눠지고 나면 덱데는 51장의 카드만 남게 되므로 두 번째 카드 변환은 두 번째로 생성된 플로트에 51을 곱하여 수행됩니다. 이는 필요한 모든 게임 이벤트가 생성될 때까지 같은 방식으로 계속됩니다.',
      shuffleDesc3: '마인과 케노의 경우, 비디오 포커에서 설명한 것과 동일한 프로세스를 구현하는 간단한 문제이지만, 타일이나 보드 또는 그리드의 위치로 변경하여 생성된 각 게임 이벤트가 결과 체인에서 미리 수행되지 않았는지 확인하는 것입니다.',
    },
    'ja-JP': {
      bytesToFloats: 'バイトから浮動小数点数へ',
      bytesDesc: '乱数ジェネレータ（byteGenerator）関数の出力は、16進数32バイトのハッシュです。カーソル実装の説明にあるように、4バイトのデータを使用して1つのゲーム結果を生成します。4バイトの各セットは、0から1までの浮動小数点数を生成するために使用されます（浮動小数点数を生成する際に高い精度を確保するため、1バイトではなく4バイトが使用されます）。生成された浮動小数点数を使用して、ゲームイベントに変換される前の、証明可能公平アルゴリズムの正式な出力を導出します。',
      floatsToEvents: '浮動小数点数からゲームイベントへ',
      floatsIntro: 'ランダム出力を生成するプロセスはすべてのゲームで共通ですが、ゲーム結果生成のこの時点で、浮動小数点数からゲームイベントへの変換を決定するための独自の手順が実装されます。',
      floatsDesc: 'ランダムに生成された浮動小数点数に、現在プレイ中のゲームの残りの可能な結果が掛けられます。例えば、52枚のカードを使用するゲームでは、浮動小数点数に52を掛けるだけで済みます。この式の結果は、対応するゲームイベントに変換されます。複数のゲームイベントが必要なゲームでは、この処理は、前述のbyteGenerator関数を使用して生成された結果チェーン内の対応する4バイトごとに継続されます。',
      shuffleTitle: 'ゲームイベントのシャッフル',
      shuffleDesc1: 'キノ、マインズ、ビデオポーカーなど、結果を再現できないゲームでは、<a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">フィッシャー・イェーツ・シャッフルアルゴリズム <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>を使用します。この手順は、浮動小数点数からゲームイベントへの変換プロセスに影響を与えます。ゲームイベントが変換されるたびに、結果チェーンの残りのステップで可能なゲームイベントの数が減少するためです。',
      shuffleDesc2: 'たとえば、ビデオポーカーでは、最初はデッキ全体で52枚のカードが用意されているため、最初のゲームイベントは float に52を掛けて変換されます。このカードが配られた後は、デッキに残っているカードは51枚だけなので、2番目のカードの変換は、生成された2番目の float に51を掛けて行われます。必要なゲームイベントがすべて生成されるまで、この処理が同じように続行されます。',
      shuffleDesc3: 'マインズとキノに関しては、ビデオポーカーで説明したのと同じプロセスを実装するだけですが、それをボードまたはグリッド上のタイルと場所に変更し、生成される各ゲームイベントが結果のチェーン内で事前に実行されていないことを確認します。',
    },
    'tl-PH': {
      bytesToFloats: 'Bytes sa Floats',
      bytesDesc: 'Ang output ng Random Number Generator (byteGenerator) function ay isang hexadecimal na 32-byte na hash. Gaya ng ipinaliwanag sa ilalim ng pagpapatupad ng cursor, gumagamit kami ng 4 na byte ng data upang makabuo ng isang resulta ng laro. Ang bawat hanay ng 4 na byte ay ginagamit upang bumuo ng mga float sa pagitan ng 0 at 1 (4 na byte ang ginagamit sa halip na isa upang matiyak ang mas mataas na antas ng katumpakan kapag bumubuo ng float.) Sa mga nabuong float na ito, nakukuha natin ang pormal na output ng mapapatunayang patas na algorithm bago ito isalin sa mga kaganapan sa laro.',
      floatsToEvents: 'Lumutang sa Mga Kaganapan sa Laro',
      floatsIntro: 'Kung saan ang proseso ng pagbuo ng mga random na output ay pangkalahatan para sa lahat ng aming mga laro, ito ay sa puntong ito sa pagbuo ng kinalabasan ng laro kung saan ipinapatupad ang isang natatanging pamamaraan upang matukoy ang pagsasalin mula sa mga float patungo sa mga kaganapan sa laro.',
      floatsDesc: 'Ang random na nabuong float ay pinarami ng posibleng natitirang resulta ng partikular na larong nilalaro. Halimbawa: Sa isang laro na gumagamit ng 52 card deck, ito ay gagawin lamang sa pamamagitan ng pagpaparami ng float sa 52. Ang resulta ng equation na ito ay isinalin sa isang katumbas na kaganapan ng laro. Para sa mga laro kung saan kinakailangan ang maraming kaganapan sa laro, nagpapatuloy ang prosesong ito sa bawat katumbas na 4 na byte sa chain ng resulta na nabuo gamit ang inilarawang function na byteGenerator.',
      shuffleTitle: 'Pagkakasunod-sunod ng mga Kaganapan sa Laro',
      shuffleDesc1: 'Para sa mga laro tulad ng Keno, Mines at Video Poker, kung saan hindi maaaring duplicate ang mga resulta, gagamitin namin ang <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">Fisher-Yates shuffle algorithm <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>. Ang pamamaraang ito ay nakakaimpluwensya sa proseso ng conversion mula sa mga float patungo sa mga kaganapan sa laro dahil sa tuwing isasalin ang isang kaganapan sa laro, ang dami ng posibleng natitirang mga posibilidad ng kaganapan sa laro ay nabawasan para sa anumang natitirang mga hakbang sa chain ng resulta.',
      shuffleDesc2: 'Bilang halimbawa, sa video poker, sa una ay mayroong 52 card na available sa kumpletong deck, at samakatuwid ang unang game event ay isinalin sa pamamagitan ng pagpaparami ng float sa 52. Kapag ang card na ito ay naibigay na, 51 na lang ang natitirang card sa deck, at samakatuwid ang pangalawang card translation ay ginagawa sa pamamagitan ng pag-multiply ng pangalawang float na nabuo sa 51. Ito ay magpapatuloy sa parehong paraan hanggang sa mabuo ang lahat ng kinakailangang event.',
      shuffleDesc3: 'Tungkol sa Mines at Keno, ito ay isang bagay lamang ng pagpapatupad ng parehong proseso tulad ng ipinaliwanag sa video poker ngunit ang pagpapalit nito sa mga tile o lokasyon sa board o grid, na tinitiyak na ang bawat kaganapan sa laro na nabuo, ay hindi pa nagagawa nang maaga sa hanay ng mga resulta.',
    },
    'es-ES': {
      bytesToFloats: 'Conversión de bytes a números de punto flotante',
      bytesDesc: 'La salida de la función Generador de Números Aleatorios (byteGenerator) es un hash hexadecimal de 32 bytes. Como se explica en la implementación del cursor, utilizamos 4 bytes de datos para generar un único resultado de juego. Cada conjunto de 4 bytes se usa para generar números de punto flotante entre 0 y 1 (se usan 4 bytes en lugar de uno para garantizar una mayor precisión en la generación del número de punto flotante). Con estos números de punto flotante generados, obtenemos la salida formal del algoritmo de imparcialidad demostrable antes de que se traduzca en eventos de juego.',
      floatsToEvents: 'De Floats a Eventos de Juego',
      floatsIntro: 'Si bien el proceso de generación de resultados aleatorios es universal para todos nuestros juegos, es en este punto de la generación del resultado del juego donde se implementa un procedimiento único para determinar la traducción de números de punto flotante a eventos del juego.',
      floatsDesc: 'El número decimal generado aleatoriamente se multiplica por los posibles resultados restantes de la partida en cuestión. Por ejemplo: en una partida con una baraja de 52 cartas, esto se realiza simplemente multiplicando el número decimal por 52. El resultado de esta operación se traduce en un evento de juego correspondiente. En partidas que requieren múltiples eventos, este proceso se repite para cada uno de los 4 bytes correspondientes en la cadena de resultados generada mediante la función byteGenerator descrita.',
      shuffleTitle: 'Barajado de Eventos del Juego',
      shuffleDesc1: 'Para juegos como Keno, Mines y Video Poker, donde los resultados no se pueden duplicar, utilizamos entonces el algoritmo de <a href="https://en.wikipedia.org/wiki/Fisher–Yates_shuffle" target="_blank" class="text-[#fff] inline-flex items-center gap-1">barajado Fisher-Yates <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg></a>. Este procedimiento influye en el proceso de conversión de números de punto flotante a eventos de juego porque cada vez que se traduce un evento de juego, se reduce la cantidad de posibles eventos de juego restantes para cualquier paso restante en la cadena de resultados.',
      shuffleDesc2: 'Por ejemplo, en el video póker, inicialmente hay 52 cartas disponibles en la baraja completa, por lo que el primer evento del juego se traduce multiplicando el valor flotante por 52. Una vez repartida esta carta, quedan 51 cartas en la baraja, por lo que la traducción de la segunda carta se realiza multiplicando el segundo valor flotante generado por 51. Este proceso continúa de la misma manera hasta que se hayan generado todos los eventos del juego necesarios.',
      shuffleDesc3: 'En lo que respecta a Mines y Keno, se trata simplemente de implementar el mismo proceso que se explicó para el video póker, pero cambiándolo a fichas o ubicaciones en el tablero o cuadrícula, asegurando que cada evento de juego generado no se haya realizado ya de antemano en la cadena de resultados.',
    },
  }

  return translations[lang] || translations['en-US']
})
</script>

<template>
  <div>
    <!-- Bytes to Floats -->
    <div class="text-[#fff] text-[16px] font-semibold leading-[1.32]">
      {{ t.bytesToFloats }}
    </div>
    <div class="text-[#b1bad3] mt-[14px] text-[14px] leading-[1.5] @md:text-[18px]" v-html="t.bytesDesc" />

    <!-- Code Block (保持英文) -->
    <div class="text-[#fff] scroll-x bg-[#213743] mt-[14px] rounded-[4px] p-[14px] text-[14px] leading-[1.5] @md:text-[18px] overflow-x-auto">
      <pre><code style="font-family: monospace,monospace;font-size: 1em;">// Convert the hash output from the rng byteGenerator to floats
function generateFloats ({ serverSeed, clientSeed, nonce, cursor, count }) {
  const rng = byteGenerator({ serverSeed, clientSeed, nonce, cursor });
  const bytes = [];

  while (bytes.length &lt; count * 4) {
    bytes.push(rng.next().value);
  }

  return _.chunk(bytes, 4).map(bytesChunk =>
    bytesChunk.reduce((result, value, i) => {
      const divider = 256 ** (i + 1);
      const partialResult = value / divider;
      return result + partialResult;
    }, 0)
  );
};</code></pre>
    </div>

    <!-- Floats to Game Events -->
    <div class="text-[#fff] mt-[14px] text-[16px] font-semibold leading-[1.32]">
      {{ t.floatsToEvents }}
    </div>
    <div class="text-[#b1bad3] mt-[14px] text-[14px] leading-[1.5] @md:text-[18px]" v-html="t.floatsIntro" />
    <div class="text-[#b1bad3] mt-[14px] text-[14px] leading-[1.5] @md:text-[18px]" v-html="t.floatsDesc" />

    <!-- Shuffle of Game Events -->
    <div class="text-[#fff] mt-[14px] text-[16px] font-semibold leading-[1.32]">
      {{ t.shuffleTitle }}
    </div>
    <div class="text-[#b1bad3] mt-[14px] text-[14px] leading-[1.5] @md:text-[18px]" v-html="t.shuffleDesc1" />
    <div class="text-[#b1bad3] mt-[14px] text-[14px] leading-[1.5] @md:text-[18px]" v-html="t.shuffleDesc2" />
    <div class="text-[#b1bad3] mt-[14px] text-[14px] leading-[1.5] @md:text-[18px]" v-html="t.shuffleDesc3" />
  </div>
</template>

<style lang="scss" scoped>
.scroll-x {
  overflow-x: auto;
}
pre {
  margin: 0;
  white-space: pre;
}
</style>
