<script lang="ts" setup>
import { IconUniJumpPage } from '@tg/icons'

</script>

<template>
  <div>
    <div class="text-tg-text-white text-[20px] font-semibold leading-[1.32] @md:text-[28px]">
      Bytes to Floats
    </div>
    <div class="text-tg-secondary-light mt-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      The output of the Random Number Generator (byteGenerator) function is a hexadecimal 32-byte hash. As explained under the cursor implementation, we use 4 bytes of data to generate a single game result. Each set of 4 bytes are used to generate floats between 0 and 1 (4 bytes are used instead of one to ensure a higher level of precision when generating the float.) It is with these generated floats that we derive the formal output of the provable fair algorithm before it is translated into game events.
    </div>
    <div class="text-tg-text-white scroll-x bg-tg-secondary-grey mt-[16px] rounded-[4px] p-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      <pre><code style="font-family: monospace,monospace;font-size: 1em;">// Convert the hash output from the rng byteGenerator to floats
function generateFloats ({ serverSeed, clientSeed, nonce, cursor, count }) {
  // Random number generator function
  const rng = byteGenerator({ serverSeed, clientSeed, nonce, cursor });
  // Declare bytes as empty array
  const bytes = [];

  // Populate bytes array with sets of 4 from RNG output
  while (bytes.length &lt; count * 4) {
    bytes.push(rng.next().value);
  }

  // Return bytes as floats using lodash reduce function
  return _.chunk(bytes, 4).map(bytesChunk =>
    bytesChunk.reduce((result, value, i) => {
      const divider = 256 ** (i + 1);
      const partialResult = value / divider;
      return result + partialResult;
    }, 0)
  );
};</code></pre>
    </div>
    <div class="text-tg-text-white mt-[16px] text-[20px] font-semibold leading-[1.32] @md:text-[28px]">
      Floats to Game Events
    </div>
    <div class="text-tg-secondary-light mt-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      Where the process of generating random outputs is universal for all our games, it's at this point in the game outcome generation where a unique procedure is implemented to determine the translation from floats to game events.
    </div>
    <div class="text-tg-secondary-light mt-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      The randomly float generated is multiplied by the possible remaining outcomes of the particular game being played. For example: In a game that uses a 52 card deck, this would simply be done by multiplying the float by 52. The result of this equation is then translated into a corresponding game event. For games where multiple game events are required, this process continues through each corresponding 4 bytes in the result chain that was generated using the described byteGenerator function.
    </div>
    <div class="text-tg-text-white mt-[16px] text-[20px] font-semibold leading-[1.32] @md:text-[28px]">
      Shuffle of Game Events
    </div>
    <div class="text-tg-secondary-light mt-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      For games such as Keno, Mines and Video Poker, where outcomes cannot be duplicated, we then utilise the <a class="text-tg-text-white center inline-flex gap-[4px] text-[14px]" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank">Fisher-Yates shuffle <IconUniJumpPage class="text-[12px]"  /></a> algorithm. This procedure influences the conversion process from floats to game events because each time a game event is translated, the amount of possible remaining game event possibilities has been reduced for any remaining steps in the result chain.
    </div>
    <div class="text-tg-secondary-light mt-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      As an example, in video poker, there is at first 52 cards available in the complete deck, and therefore the first game event is translated by multiplying the float by 52. Once this card has been dealt, there is only 51 remaining cards in the deck, and therefore the second card translation is done by multiplying the second float generated by 51. This continues in the same fashion until all the game events required have been generated.
    </div>
    <div class="text-tg-secondary-light mt-[16px] text-[16px] leading-[1.5] @md:text-[18px]">
      With regards to Mines and Keno, this is simply a matter of implementing the same process as explained with video poker but changing that to tiles or locations on the board or grid, ensuring that each game event generated, hasnâ€™t already been done so beforehand in the chain of results.
    </div>
  </div>
</template>

<style lang="scss" scoped></style>
